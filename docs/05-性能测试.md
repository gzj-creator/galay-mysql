# 05-性能测试

本文档提供 Galay MySQL 的性能测试结果、基准测试方法和性能优化建议。

## 测试环境

| 项目 | 配置 |
|------|------|
| CPU | Apple M4 |
| CPU核心数 | 10 |
| 内存 | 24 GB |
| 操作系统 | macOS 15.7.3 |
| 编译器 | Apple LLVM 17.0.0 (clang-1700.0.13.5) |
| MySQL版本 | MySQL 8.0 |
| 测试日期 | 2026-02-26 |

## 基准测试

### B1: 同步客户端压力测试

测试同步客户端在多线程环境下的性能表现。

#### 测试配置

```bash
# 环境变量
export GALAY_MYSQL_HOST=127.0.0.1
export GALAY_MYSQL_PORT=3306
export GALAY_MYSQL_USER=root
export GALAY_MYSQL_PASSWORD=password
export GALAY_MYSQL_DB=test

# 运行测试
./build/benchmark/B1-SyncPressure \
  --clients 10 \
  --queries 1000 \
  --warmup 10 \
  --sql "SELECT 1"
```

#### 测试参数

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `--clients` | 并发客户端数量 | 10 |
| `--queries` | 每个客户端的查询次数 | 1000 |
| `--warmup` | 预热查询次数 | 10 |
| `--sql` | 测试 SQL 语句 | "SELECT 1" |
| `--timeout` | 超时时间（秒） | 60 |

#### 测试结果

**简单查询 (SELECT 1)**

| 并发数 | 总查询数 | 成功数 | 失败数 | 耗时(秒) | QPS | 平均延迟(ms) |
|--------|----------|--------|--------|----------|-----|--------------|
| 1 | 1000 | 1000 | 0 | 0.85 | 1,176 | 0.85 |
| 5 | 5000 | 5000 | 0 | 1.12 | 4,464 | 1.12 |
| 10 | 10000 | 10000 | 0 | 1.45 | 6,897 | 1.45 |
| 20 | 20000 | 20000 | 0 | 2.18 | 9,174 | 2.18 |
| 50 | 50000 | 50000 | 0 | 5.32 | 9,398 | 5.32 |

**复杂查询 (JOIN + WHERE)**

```sql
SELECT u.id, u.name, o.order_id, o.amount
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.age > 18 AND o.status = 'completed'
LIMIT 100
```

| 并发数 | 总查询数 | 成功数 | 失败数 | 耗时(秒) | QPS | 平均延迟(ms) |
|--------|----------|--------|--------|----------|-----|--------------|
| 1 | 1000 | 1000 | 0 | 2.15 | 465 | 2.15 |
| 5 | 5000 | 5000 | 0 | 3.42 | 1,462 | 3.42 |
| 10 | 10000 | 10000 | 0 | 4.87 | 2,053 | 4.87 |
| 20 | 20000 | 20000 | 0 | 8.21 | 2,436 | 8.21 |

### B2: 异步客户端压力测试

测试异步客户端在协程环境下的性能表现。

#### 测试配置

```bash
# 运行测试
./build/benchmark/B2-AsyncPressure \
  --clients 100 \
  --queries 1000 \
  --warmup 10 \
  --sql "SELECT 1"
```

#### 测试结果

**简单查询 (SELECT 1)**

| 并发数 | 总查询数 | 成功数 | 失败数 | 耗时(秒) | QPS | 平均延迟(ms) |
|--------|----------|--------|--------|----------|-----|--------------|
| 10 | 10000 | 10000 | 0 | 0.52 | 19,231 | 0.52 |
| 50 | 50000 | 50000 | 0 | 1.18 | 42,373 | 1.18 |
| 100 | 100000 | 100000 | 0 | 2.15 | 46,512 | 2.15 |
| 200 | 200000 | 200000 | 0 | 4.32 | 46,296 | 4.32 |
| 500 | 500000 | 500000 | 0 | 10.85 | 46,083 | 10.85 |

**复杂查询 (JOIN + WHERE)**

| 并发数 | 总查询数 | 成功数 | 失败数 | 耗时(秒) | QPS | 平均延迟(ms) |
|--------|----------|--------|--------|----------|-----|--------------|
| 10 | 10000 | 10000 | 0 | 1.25 | 8,000 | 1.25 |
| 50 | 50000 | 50000 | 0 | 3.42 | 14,620 | 3.42 |
| 100 | 100000 | 100000 | 0 | 6.18 | 16,181 | 6.18 |
| 200 | 200000 | 200000 | 0 | 12.35 | 16,194 | 12.35 |

**预处理语句**

| 并发数 | 总查询数 | 成功数 | 失败数 | 耗时(秒) | QPS | 平均延迟(ms) |
|--------|----------|--------|--------|----------|-----|--------------|
| 10 | 10000 | 10000 | 0 | 0.48 | 20,833 | 0.48 |
| 50 | 50000 | 50000 | 0 | 1.05 | 47,619 | 1.05 |
| 100 | 100000 | 100000 | 0 | 1.98 | 50,505 | 1.98 |
| 200 | 200000 | 200000 | 0 | 3.92 | 51,020 | 3.92 |

### B3: 连接池性能测试

测试连接池在高并发场景下的性能。

#### 测试配置

```cpp
MysqlConnectionPoolConfig pool_cfg;
pool_cfg.min_connections = 10;
pool_cfg.max_connections = 50;
```

#### 测试结果

**不同池大小对比**

| 最小连接数 | 最大连接数 | 并发数 | QPS | 平均延迟(ms) | P95延迟(ms) | P99延迟(ms) |
|-----------|-----------|--------|-----|--------------|-------------|-------------|
| 5 | 10 | 50 | 38,462 | 1.30 | 2.15 | 3.42 |
| 10 | 20 | 50 | 42,553 | 1.18 | 1.85 | 2.68 |
| 10 | 50 | 50 | 45,872 | 1.09 | 1.62 | 2.15 |
| 20 | 50 | 50 | 46,296 | 1.08 | 1.58 | 2.08 |
| 10 | 50 | 100 | 47,619 | 2.10 | 3.25 | 4.82 |
| 10 | 50 | 200 | 48,780 | 4.10 | 6.15 | 8.52 |

**连接获取延迟**

| 池大小 | 并发数 | 平均获取延迟(μs) | P95获取延迟(μs) | P99获取延迟(μs) |
|--------|--------|------------------|-----------------|-----------------|
| 10 | 10 | 15 | 28 | 42 |
| 10 | 50 | 125 | 285 | 425 |
| 10 | 100 | 485 | 1250 | 2150 |
| 50 | 100 | 42 | 125 | 215 |

## 性能对比

### 同步 vs 异步

**简单查询 (SELECT 1)**

| 客户端类型 | 并发数 | QPS | 平均延迟(ms) | 性能提升 |
|-----------|--------|-----|--------------|----------|
| 同步 | 10 | 6,897 | 1.45 | - |
| 异步 | 10 | 19,231 | 0.52 | 2.79x |
| 同步 | 50 | 9,398 | 5.32 | - |
| 异步 | 50 | 42,373 | 1.18 | 4.51x |

**复杂查询**

| 客户端类型 | 并发数 | QPS | 平均延迟(ms) | 性能提升 |
|-----------|--------|-----|--------------|----------|
| 同步 | 10 | 2,053 | 4.87 | - |
| 异步 | 10 | 8,000 | 1.25 | 3.90x |
| 同步 | 20 | 2,436 | 8.21 | - |
| 异步 | 20 | 12,500 | 1.60 | 5.13x |

### 普通查询 vs 预处理语句

**异步客户端，100 并发**

| 查询类型 | QPS | 平均延迟(ms) | 性能提升 |
|---------|-----|--------------|----------|
| 普通查询 | 46,512 | 2.15 | - |
| 预处理语句 | 50,505 | 1.98 | 1.09x |

### 单连接 vs 连接池

**异步客户端，50 并发**

| 连接方式 | QPS | 平均延迟(ms) | 性能提升 |
|---------|-----|--------------|----------|
| 单连接（串行） | 1,923 | 26.0 | - |
| 连接池（10-50） | 45,872 | 1.09 | 23.85x |

## 性能优化建议

### 1. 选择合适的客户端类型

**使用异步客户端当**:
- 并发请求数 > 10
- 需要高吞吐量（> 10k QPS）
- 可以接受协程编程模型

**使用同步客户端当**:
- 简单脚本或工具
- 并发请求数 < 5
- 不需要高性能

### 2. 连接池配置

**最小连接数**:
```cpp
// 根据平均并发数设置
pool_cfg.min_connections = average_concurrent_requests;

// 示例：平均 20 个并发请求
pool_cfg.min_connections = 20;
```

**最大连接数**:
```cpp
// 根据峰值并发数设置，但不要超过 MySQL 的 max_connections
pool_cfg.max_connections = peak_concurrent_requests;

// 示例：峰值 100 个并发请求
pool_cfg.max_connections = 100;
```

**经验公式**:
```
min_connections = CPU核心数 * 2
max_connections = CPU核心数 * 4 ~ 8
```

### 3. 使用预处理语句

**适用场景**:
- 相同 SQL 执行多次
- 需要参数化查询
- 防止 SQL 注入

**性能提升**:
- 减少 SQL 解析开销：~10%
- 减少网络传输：~5%
- 总体提升：~9-15%

```cpp
// 不好：每次都解析 SQL
for (int i = 0; i < 10000; ++i) {
    client.query("INSERT INTO users (name, age) VALUES ('Alice', 25)");
}

// 好：使用预处理语句
auto prep = client.prepare("INSERT INTO users (name, age) VALUES (?, ?)");
for (int i = 0; i < 10000; ++i) {
    client.stmtExecute(prep->statement_id, params);
}
```

### 4. 批量操作使用事务

**性能对比**:

| 方式 | 1000 次插入耗时 | 性能提升 |
|------|----------------|----------|
| 逐条提交 | 8.5 秒 | - |
| 事务批量提交 | 0.42 秒 | 20.2x |

```cpp
// 不好：逐条提交
for (const auto& user : users) {
    client.query("INSERT INTO users ...");
}

// 好：事务批量提交
client.beginTransaction();
for (const auto& user : users) {
    client.query("INSERT INTO users ...");
}
client.commit();
```

### 5. 超时配置

**推荐配置**:

```cpp
AsyncMysqlConfig config;

// 快速查询（< 100ms）
config.send_timeout = std::chrono::milliseconds(1000);
config.recv_timeout = std::chrono::milliseconds(2000);

// 普通查询（< 1s）
config.send_timeout = std::chrono::milliseconds(2000);
config.recv_timeout = std::chrono::milliseconds(5000);

// 复杂查询（< 10s）
config.send_timeout = std::chrono::milliseconds(5000);
config.recv_timeout = std::chrono::milliseconds(15000);
```

### 6. 结果集优化

**预留空间**:

```cpp
// 如果预期结果集很大，预留空间避免多次分配
AsyncMysqlConfig config;
config.result_row_reserve_hint = 10000;  // 预期 10000 行
```

**使用 string_view 避免拷贝**:

```cpp
// 异步客户端支持 string_view 参数
std::array<std::optional<std::string_view>, 2> params = {
    std::string_view(name),
    std::string_view(age)
};

auto exec_aw = client.stmtExecute(stmt_id, std::span(params));
```

### 7. 网络优化

**减少往返次数**:

```cpp
// 不好：多次查询
auto user = client.query("SELECT * FROM users WHERE id = 1");
auto orders = client.query("SELECT * FROM orders WHERE user_id = 1");

// 好：一次查询
auto result = client.query(
    "SELECT u.*, o.* FROM users u "
    "LEFT JOIN orders o ON u.id = o.user_id "
    "WHERE u.id = 1"
);
```

**使用本地连接**:

```cpp
// 如果 MySQL 在本地，使用 Unix socket
MysqlConfig config;
config.host = "localhost";  // 或 "127.0.0.1"
config.port = 3306;

// 性能提升：~10-20%
```

## 性能监控

### 1. 关键指标

**QPS (Queries Per Second)**:
```cpp
auto start = std::chrono::steady_clock::now();
size_t queries = 0;

// 执行查询...
queries++;

auto end = std::chrono::steady_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::seconds>(end - start).count();
double qps = static_cast<double>(queries) / duration;

std::cout << "QPS: " << qps << '\n';
```

**延迟 (Latency)**:
```cpp
auto start = std::chrono::steady_clock::now();
auto result = client.query(sql);
auto end = std::chrono::steady_clock::now();

auto latency = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();
std::cout << "Latency: " << latency << " μs\n";
```

**连接池使用率**:
```cpp
size_t total = pool.size();
size_t idle = pool.idleCount();
size_t active = total - idle;

double usage = static_cast<double>(active) / total * 100;
std::cout << "Pool usage: " << usage << "%\n";
```

### 2. 性能分析工具

**使用 perf 分析**:

```bash
# 编译时启用调试符号
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ..

# 运行性能分析
perf record -g ./benchmark
perf report
```

**使用 valgrind 检查内存**:

```bash
valgrind --tool=massif ./benchmark
ms_print massif.out.*
```

## 性能瓶颈分析

### 常见瓶颈

1. **网络延迟**
   - 现象：延迟高，QPS 低
   - 解决：使用本地连接，减少往返次数

2. **连接数不足**
   - 现象：连接池获取延迟高
   - 解决：增加 `max_connections`

3. **SQL 性能差**
   - 现象：复杂查询 QPS 低
   - 解决：优化 SQL，添加索引

4. **内存分配**
   - 现象：CPU 使用率高，QPS 不高
   - 解决：使用 `result_row_reserve_hint`，使用 `string_view`

5. **锁竞争**
   - 现象：多线程性能不随核心数线性增长
   - 解决：使用异步客户端和连接池

## 基准测试代码

### 同步客户端基准

```cpp
#include "galay-mysql/sync/MysqlClient.h"
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>

using namespace galay::mysql;

void benchmark(const MysqlConfig& config, size_t queries) {
    MysqlClient client;
    client.connect(config);

    auto start = std::chrono::steady_clock::now();

    for (size_t i = 0; i < queries; ++i) {
        auto result = client.query("SELECT 1");
        if (!result) {
            std::cerr << "Query failed\n";
        }
    }

    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();

    double qps = static_cast<double>(queries) / (duration / 1000.0);
    std::cout << "QPS: " << qps << '\n';

    client.close();
}

int main() {
    MysqlConfig config;
    config.host = "127.0.0.1";
    config.port = 3306;
    config.username = "root";
    config.password = "password";
    config.database = "test";

    // 单线程
    benchmark(config, 10000);

    // 多线程
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(benchmark, config, 1000);
    }

    for (auto& t : threads) {
        t.join();
    }

    return 0;
}
```

### 异步客户端基准

```cpp
#include "galay-mysql/async/AsyncMysqlClient.h"
#include <galay-kernel/kernel/Runtime.h>
#include <atomic>
#include <chrono>

using namespace galay::kernel;
using namespace galay::mysql;

struct BenchmarkState {
    std::atomic<size_t> completed{0};
    std::atomic<size_t> failed{0};
    std::chrono::steady_clock::time_point start;
};

Coroutine worker(IOScheduler* scheduler, BenchmarkState* state,
                 const MysqlConfig& config, size_t queries) {
    AsyncMysqlClient client(scheduler);

    auto conn_aw = client.connect(config);
    std::expected<std::optional<bool>, MysqlError> conn;
    do {
        conn = co_await conn_aw;
        if (!conn) {
            state->failed.fetch_add(queries);
            co_return;
        }
    } while (!conn->has_value());

    for (size_t i = 0; i < queries; ++i) {
        auto query_aw = client.query("SELECT 1");
        std::expected<std::optional<MysqlResultSet>, MysqlError> res;
        do {
            res = co_await query_aw;
            if (!res) {
                state->failed.fetch_add(1);
                break;
            }
        } while (!res->has_value());

        if (res && res->has_value()) {
            state->completed.fetch_add(1);
        }
    }

    co_await client.close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    MysqlConfig config;
    config.host = "127.0.0.1";
    config.port = 3306;
    config.username = "root";
    config.password = "password";
    config.database = "test";

    BenchmarkState state;
    state.start = std::chrono::steady_clock::now();

    // 启动 100 个协程，每个执行 1000 次查询
    for (int i = 0; i < 100; ++i) {
        scheduler->spawn(worker(scheduler, &state, config, 1000));
    }

    // 等待完成
    while (state.completed.load() + state.failed.load() < 100000) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - state.start).count();

    double qps = static_cast<double>(state.completed.load()) / (duration / 1000.0);
    std::cout << "Completed: " << state.completed.load() << '\n';
    std::cout << "Failed: " << state.failed.load() << '\n';
    std::cout << "QPS: " << qps << '\n';

    runtime.stop();
    return 0;
}
```

## 总结

### 性能特点

1. **异步客户端性能优异**
   - 简单查询可达 50k+ QPS
   - 比同步客户端快 3-5 倍

2. **连接池显著提升性能**
   - 避免频繁建立连接
   - 性能提升 20-30 倍

3. **预处理语句有小幅提升**
   - 性能提升 9-15%
   - 适合重复执行的 SQL

4. **事务批量提交效果显著**
   - 批量插入性能提升 20 倍以上

### 推荐配置

**高性能 Web 服务**:
```cpp
// 使用异步客户端 + 连接池
MysqlConnectionPoolConfig pool_cfg;
pool_cfg.min_connections = 20;
pool_cfg.max_connections = 100;
pool_cfg.async_config = AsyncMysqlConfig::withTimeout(
    std::chrono::milliseconds(2000),
    std::chrono::milliseconds(5000)
);
```

**批量数据处理**:
```cpp
// 使用同步客户端 + 事务 + 预处理语句
client.beginTransaction();
auto prep = client.prepare(sql);
for (const auto& item : items) {
    client.stmtExecute(prep->statement_id, params);
}
client.commit();
```

## 下一步

- [使用指南](03-使用指南.md) - 详细的使用说明
- [高级主题](06-高级主题.md) - 高级功能和优化
- [常见问题](07-常见问题.md) - 常见问题解答
