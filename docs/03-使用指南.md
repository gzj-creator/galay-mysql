# 03-使用指南

本文档提供 Galay MySQL 的详细使用说明、最佳实践和常见场景。

## 选择客户端类型

### 同步 vs 异步

| 特性 | 同步客户端 (MysqlClient) | 异步客户端 (AsyncMysqlClient) |
|------|-------------------------|------------------------------|
| 适用场景 | 简单脚本、测试工具 | 高并发服务、Web 应用 |
| 编程模型 | 阻塞调用 | 协程异步 |
| 性能 | 中等 | 高 |
| 复杂度 | 简单 | 中等 |
| 连接池 | 不支持 | 支持 |
| 依赖 | 无 | galay-kernel |

### 使用建议

**选择同步客户端当**:
- 编写简单的数据库脚本
- 单元测试和集成测试
- 命令行工具
- 低并发场景（< 10 QPS）

**选择异步客户端当**:
- 构建 Web 服务
- 需要高并发（> 100 QPS）
- 需要连接池管理
- 与其他异步组件集成

## 同步客户端使用指南

### 1. 基本连接

```cpp
#include "galay-mysql/sync/MysqlClient.h"
#include <iostream>

using namespace galay::mysql;

int main() {
    MysqlClient client;

    // 方式 1: 使用配置对象
    MysqlConfig config;
    config.host = "127.0.0.1";
    config.port = 3306;
    config.username = "root";
    config.password = "password";
    config.database = "test";
    config.charset = "utf8mb4";
    config.connect_timeout_ms = 5000;

    auto conn = client.connect(config);
    if (!conn) {
        std::cerr << "连接失败: " << conn.error().message() << '\n';
        return 1;
    }

    // 方式 2: 直接传参
    auto conn2 = client.connect("127.0.0.1", 3306, "root", "password", "test");
    if (!conn2) {
        std::cerr << "连接失败: " << conn2.error().message() << '\n';
        return 1;
    }

    std::cout << "连接成功\n";
    client.close();
    return 0;
}
```

### 2. 执行查询

#### 简单查询

```cpp
auto result = client.query("SELECT id, name, email FROM users WHERE age > 18");
if (!result) {
    std::cerr << "查询失败: " << result.error().message() << '\n';
    return;
}

const MysqlResultSet& rs = result.value();
if (rs.hasResultSet()) {
    std::cout << "查询到 " << rs.rowCount() << " 条记录\n";

    for (size_t i = 0; i < rs.rowCount(); ++i) {
        const auto& row = rs.row(i);
        std::cout << "ID: " << row.getString(0)
                  << ", Name: " << row.getString(1)
                  << ", Email: " << row.getString(2) << '\n';
    }
} else {
    std::cout << "影响行数: " << rs.affectedRows() << '\n';
}
```

#### 插入数据

```cpp
auto result = client.query(
    "INSERT INTO users (name, email, age) VALUES ('Alice', 'alice@example.com', 25)"
);

if (result) {
    const auto& rs = result.value();
    std::cout << "插入成功, ID: " << rs.lastInsertId() << '\n';
    std::cout << "影响行数: " << rs.affectedRows() << '\n';
}
```

#### 更新和删除

```cpp
// 更新
auto update_result = client.query("UPDATE users SET age = 26 WHERE name = 'Alice'");
if (update_result) {
    std::cout << "更新了 " << update_result->affectedRows() << " 行\n";
}

// 删除
auto delete_result = client.query("DELETE FROM users WHERE age < 18");
if (delete_result) {
    std::cout << "删除了 " << delete_result->affectedRows() << " 行\n";
}
```

### 3. 预处理语句

预处理语句可以防止 SQL 注入，提高性能。

```cpp
// 准备语句
auto prep = client.prepare("INSERT INTO users (name, email, age) VALUES (?, ?, ?)");
if (!prep) {
    std::cerr << "预处理失败: " << prep.error().message() << '\n';
    return;
}

uint32_t stmt_id = prep->statement_id;
std::cout << "预处理成功, statement_id: " << stmt_id << '\n';

// 执行语句
std::vector<std::optional<std::string>> params = {"Bob", "bob@example.com", "30"};
auto exec = client.stmtExecute(stmt_id, params);
if (exec) {
    std::cout << "插入成功, ID: " << exec->lastInsertId() << '\n';
}

// 关闭语句
client.stmtClose(stmt_id);
```

#### 批量插入

```cpp
auto prep = client.prepare("INSERT INTO users (name, age) VALUES (?, ?)");
if (!prep) return;

uint32_t stmt_id = prep->statement_id;

// 批量插入
std::vector<std::pair<std::string, int>> users = {
    {"Alice", 25}, {"Bob", 30}, {"Charlie", 35}
};

for (const auto& [name, age] : users) {
    std::vector<std::optional<std::string>> params = {
        name, std::to_string(age)
    };

    auto exec = client.stmtExecute(stmt_id, params);
    if (!exec) {
        std::cerr << "插入失败: " << exec.error().message() << '\n';
    }
}

client.stmtClose(stmt_id);
```

### 4. 事务处理

```cpp
// 开启事务
auto begin = client.beginTransaction();
if (!begin) {
    std::cerr << "开启事务失败\n";
    return;
}

try {
    // 执行多个操作
    auto insert1 = client.query("INSERT INTO accounts (user_id, balance) VALUES (1, 1000)");
    if (!insert1) throw std::runtime_error("插入失败");

    auto insert2 = client.query("INSERT INTO accounts (user_id, balance) VALUES (2, 2000)");
    if (!insert2) throw std::runtime_error("插入失败");

    auto update = client.query("UPDATE accounts SET balance = balance - 100 WHERE user_id = 1");
    if (!update) throw std::runtime_error("更新失败");

    // 提交事务
    auto commit = client.commit();
    if (!commit) {
        std::cerr << "提交失败\n";
        client.rollback();
        return;
    }

    std::cout << "事务提交成功\n";

} catch (const std::exception& e) {
    std::cerr << "事务执行失败: " << e.what() << '\n';
    client.rollback();
}
```

### 5. 错误处理

```cpp
void handleQuery(MysqlClient& client, const std::string& sql) {
    auto result = client.query(sql);

    if (!result) {
        const auto& error = result.error();

        // 根据错误类型处理
        switch (error.type()) {
            case MYSQL_ERROR_CONNECTION:
                std::cerr << "连接错误: " << error.message() << '\n';
                // 尝试重连
                break;

            case MYSQL_ERROR_SERVER:
                std::cerr << "SQL 错误 [" << error.serverErrno() << "]: "
                          << error.message() << '\n';
                // 检查具体的 MySQL 错误码
                if (error.serverErrno() == 1062) {
                    std::cerr << "重复键冲突\n";
                }
                break;

            case MYSQL_ERROR_TIMEOUT:
                std::cerr << "查询超时: " << error.message() << '\n';
                break;

            default:
                std::cerr << "未知错误: " << error.message() << '\n';
        }
        return;
    }

    // 处理结果
    const auto& rs = result.value();
    std::cout << "查询成功, 行数: " << rs.rowCount() << '\n';
}
```

## 异步客户端使用指南

### 1. 基本连接

```cpp
#include "galay-mysql/async/AsyncMysqlClient.h"
#include <galay-kernel/kernel/Runtime.h>
#include <atomic>

using namespace galay::kernel;
using namespace galay::mysql;

struct State {
    std::atomic<bool> done{false};
};

Coroutine asyncExample(IOScheduler* scheduler, State* state) {
    // 创建客户端
    AsyncMysqlClient client(scheduler);

    // 连接数据库
    auto conn_aw = client.connect("127.0.0.1", 3306, "root", "password", "test");
    std::expected<std::optional<bool>, MysqlError> conn;

    do {
        conn = co_await conn_aw;
        if (!conn) {
            std::cerr << "连接失败: " << conn.error().message() << '\n';
            state->done = true;
            co_return;
        }
    } while (!conn->has_value());

    std::cout << "连接成功\n";

    // 使用客户端...

    // 关闭连接
    co_await client.close();
    state->done = true;
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    State state;
    scheduler->spawn(asyncExample(scheduler, &state));

    while (!state.done.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    runtime.stop();
    return 0;
}
```

### 2. 执行查询

```cpp
Coroutine queryExample(IOScheduler* scheduler, AsyncMysqlClient& client) {
    auto query_aw = client.query("SELECT id, name FROM users LIMIT 10");
    std::expected<std::optional<MysqlResultSet>, MysqlError> res;

    do {
        res = co_await query_aw;
        if (!res) {
            std::cerr << "查询失败: " << res.error().message() << '\n';
            co_return;
        }
    } while (!res->has_value());

    const MysqlResultSet& rs = res->value();

    if (rs.hasResultSet()) {
        for (size_t i = 0; i < rs.rowCount(); ++i) {
            const auto& row = rs.row(i);
            std::cout << row.getString(0) << " - " << row.getString(1) << '\n';
        }
    } else {
        std::cout << "影响行数: " << rs.affectedRows() << '\n';
    }
}
```

### 3. 预处理语句

```cpp
Coroutine preparedExample(IOScheduler* scheduler, AsyncMysqlClient& client) {
    // 准备语句
    auto prep_aw = client.prepare("SELECT * FROM users WHERE age > ? AND city = ?");
    std::expected<std::optional<MysqlPrepareAwaitable::PrepareResult>, MysqlError> prep_res;

    do {
        prep_res = co_await prep_aw;
        if (!prep_res) {
            std::cerr << "预处理失败: " << prep_res.error().message() << '\n';
            co_return;
        }
    } while (!prep_res->has_value());

    uint32_t stmt_id = prep_res->value().statement_id;

    // 执行语句（使用 string_view 避免拷贝）
    std::array<std::optional<std::string_view>, 2> params = {
        std::string_view("25"),
        std::string_view("Beijing")
    };

    auto exec_aw = client.stmtExecute(stmt_id, std::span(params));
    std::expected<std::optional<MysqlResultSet>, MysqlError> exec_res;

    do {
        exec_res = co_await exec_aw;
        if (!exec_res) {
            std::cerr << "执行失败: " << exec_res.error().message() << '\n';
            co_return;
        }
    } while (!exec_res->has_value());

    const auto& rs = exec_res->value();
    std::cout << "查询到 " << rs.rowCount() << " 条记录\n";
}
```

### 4. 事务处理

```cpp
Coroutine transactionExample(IOScheduler* scheduler, AsyncMysqlClient& client) {
    // 开启事务
    auto begin_aw = client.beginTransaction();
    std::expected<std::optional<MysqlResultSet>, MysqlError> begin_res;

    do {
        begin_res = co_await begin_aw;
        if (!begin_res) {
            std::cerr << "开启事务失败\n";
            co_return;
        }
    } while (!begin_res->has_value());

    // 执行操作
    auto insert_aw = client.query("INSERT INTO orders (user_id, amount) VALUES (1, 100)");
    std::expected<std::optional<MysqlResultSet>, MysqlError> insert_res;

    do {
        insert_res = co_await insert_aw;
        if (!insert_res) {
            std::cerr << "插入失败，回滚事务\n";
            auto rb_aw = client.rollback();
            std::expected<std::optional<MysqlResultSet>, MysqlError> rb_res;
            do { rb_res = co_await rb_aw; } while (rb_res && !rb_res->has_value());
            co_return;
        }
    } while (!insert_res->has_value());

    // 提交事务
    auto commit_aw = client.commit();
    std::expected<std::optional<MysqlResultSet>, MysqlError> commit_res;

    do {
        commit_res = co_await commit_aw;
        if (!commit_res) {
            std::cerr << "提交失败，回滚事务\n";
            auto rb_aw = client.rollback();
            std::expected<std::optional<MysqlResultSet>, MysqlError> rb_res;
            do { rb_res = co_await rb_aw; } while (rb_res && !rb_res->has_value());
            co_return;
        }
    } while (!commit_res->has_value());

    std::cout << "事务提交成功\n";
}
```

### 5. 超时配置

```cpp
// 配置超时
AsyncMysqlConfig config = AsyncMysqlConfig::withTimeout(
    std::chrono::milliseconds(2000),  // 发送超时
    std::chrono::milliseconds(5000)   // 接收超时
);

AsyncMysqlClient client(scheduler, config);

// 或者只配置接收超时
AsyncMysqlConfig recv_config = AsyncMysqlConfig::withRecvTimeout(
    std::chrono::milliseconds(5000)
);

// 或者不设置超时
AsyncMysqlConfig no_timeout = AsyncMysqlConfig::noTimeout();
```

## 连接池使用指南

### 1. 基本配置

```cpp
#include "galay-mysql/async/MysqlConnectionPool.h"

// 配置 MySQL 连接
MysqlConfig mysql_cfg;
mysql_cfg.host = "127.0.0.1";
mysql_cfg.port = 3306;
mysql_cfg.username = "root";
mysql_cfg.password = "password";
mysql_cfg.database = "test";

// 配置异步参数
AsyncMysqlConfig async_cfg = AsyncMysqlConfig::withTimeout(
    std::chrono::milliseconds(3000),
    std::chrono::milliseconds(5000)
);

// 配置连接池
MysqlConnectionPoolConfig pool_cfg;
pool_cfg.mysql_config = mysql_cfg;
pool_cfg.async_config = async_cfg;
pool_cfg.min_connections = 5;   // 最小连接数
pool_cfg.max_connections = 20;  // 最大连接数

// 创建连接池
MysqlConnectionPool pool(scheduler, pool_cfg);
```

### 2. 获取和归还连接

```cpp
Coroutine usePool(IOScheduler* scheduler, MysqlConnectionPool& pool) {
    // 获取连接
    auto acq_aw = pool.acquire();
    std::expected<std::optional<AsyncMysqlClient*>, MysqlError> acq;

    do {
        acq = co_await acq_aw;
        if (!acq) {
            std::cerr << "获取连接失败: " << acq.error().message() << '\n';
            co_return;
        }
    } while (!acq->has_value());

    AsyncMysqlClient* client = acq->value();

    // 使用连接
    auto query_aw = client->query("SELECT * FROM users");
    std::expected<std::optional<MysqlResultSet>, MysqlError> res;

    do {
        res = co_await query_aw;
        if (!res) {
            std::cerr << "查询失败: " << res.error().message() << '\n';
            pool.release(client);  // 归还连接
            co_return;
        }
    } while (!res->has_value());

    // 处理结果...

    // 归还连接
    pool.release(client);
}
```

### 3. RAII 封装

```cpp
class PooledConnection {
public:
    PooledConnection(MysqlConnectionPool& pool, AsyncMysqlClient* client)
        : m_pool(pool), m_client(client) {}

    ~PooledConnection() {
        if (m_client) {
            m_pool.release(m_client);
        }
    }

    PooledConnection(const PooledConnection&) = delete;
    PooledConnection& operator=(const PooledConnection&) = delete;

    PooledConnection(PooledConnection&& other) noexcept
        : m_pool(other.m_pool), m_client(other.m_client) {
        other.m_client = nullptr;
    }

    AsyncMysqlClient* operator->() { return m_client; }
    AsyncMysqlClient& operator*() { return *m_client; }
    AsyncMysqlClient* get() { return m_client; }

private:
    MysqlConnectionPool& m_pool;
    AsyncMysqlClient* m_client;
};

Coroutine usePoolRAII(IOScheduler* scheduler, MysqlConnectionPool& pool) {
    auto acq_aw = pool.acquire();
    std::expected<std::optional<AsyncMysqlClient*>, MysqlError> acq;

    do {
        acq = co_await acq_aw;
        if (!acq) {
            std::cerr << "获取连接失败\n";
            co_return;
        }
    } while (!acq->has_value());

    // 使用 RAII 封装，自动归还
    PooledConnection conn(pool, acq->value());

    auto query_aw = conn->query("SELECT * FROM users");
    // ... 使用连接

    // 析构时自动归还
}
```

## 最佳实践

### 1. 连接管理

**及时关闭连接**:

```cpp
// 同步客户端
{
    MysqlClient client;
    client.connect(config);
    // 使用客户端...
    client.close();  // 显式关闭
}

// 异步客户端
Coroutine example(IOScheduler* scheduler) {
    AsyncMysqlClient client(scheduler);
    // 连接和使用...
    co_await client.close();  // 显式关闭
}
```

**使用连接池**:

```cpp
// 高并发场景使用连接池
MysqlConnectionPool pool(scheduler, pool_cfg);

// 多个协程共享连接池
for (int i = 0; i < 100; ++i) {
    scheduler->spawn(handleRequest(scheduler, pool, i));
}
```

### 2. 错误处理

**完整的错误检查**:

```cpp
auto result = client.query(sql);
if (!result) {
    const auto& error = result.error();

    // 记录错误日志
    logError("Query failed", error.message());

    // 根据错误类型决定是否重试
    if (error.type() == MYSQL_ERROR_TIMEOUT) {
        // 重试
        return retry(sql);
    }

    // 返回错误给上层
    return std::unexpected(error);
}
```

**事务错误处理**:

```cpp
Coroutine safeTransaction(AsyncMysqlClient& client) {
    auto begin_aw = client.beginTransaction();
    std::expected<std::optional<MysqlResultSet>, MysqlError> begin_res;

    do {
        begin_res = co_await begin_aw;
        if (!begin_res) {
            co_return std::unexpected(begin_res.error());
        }
    } while (!begin_res->has_value());

    try {
        // 执行操作...

        // 提交
        auto commit_aw = client.commit();
        std::expected<std::optional<MysqlResultSet>, MysqlError> commit_res;
        do {
            commit_res = co_await commit_aw;
            if (!commit_res) {
                throw std::runtime_error("Commit failed");
            }
        } while (!commit_res->has_value());

    } catch (...) {
        // 回滚
        auto rb_aw = client.rollback();
        std::expected<std::optional<MysqlResultSet>, MysqlError> rb_res;
        do { rb_res = co_await rb_aw; } while (rb_res && !rb_res->has_value());
        throw;
    }
}
```

### 3. 性能优化

**使用预处理语句**:

```cpp
// 不好：每次都解析 SQL
for (const auto& user : users) {
    std::string sql = "INSERT INTO users (name, age) VALUES ('" +
                      user.name + "', " + std::to_string(user.age) + ")";
    client.query(sql);
}

// 好：使用预处理语句
auto prep = client.prepare("INSERT INTO users (name, age) VALUES (?, ?)");
uint32_t stmt_id = prep->statement_id;

for (const auto& user : users) {
    std::vector<std::optional<std::string>> params = {
        user.name, std::to_string(user.age)
    };
    client.stmtExecute(stmt_id, params);
}

client.stmtClose(stmt_id);
```

**批量操作使用事务**:

```cpp
client.beginTransaction();

for (const auto& item : items) {
    client.query("INSERT INTO ...");
}

client.commit();  // 一次性提交
```

**使用 string_view 避免拷贝**:

```cpp
// 异步客户端支持 string_view 参数
std::string name = "Alice";
std::string age = "25";

std::array<std::optional<std::string_view>, 2> params = {
    std::string_view(name),
    std::string_view(age)
};

auto exec_aw = client.stmtExecute(stmt_id, std::span(params));
```

### 4. 结果集处理

**检查结果类型**:

```cpp
const auto& rs = result.value();

if (rs.hasResultSet()) {
    // SELECT 查询，有数据行
    for (size_t i = 0; i < rs.rowCount(); ++i) {
        const auto& row = rs.row(i);
        // 处理行数据
    }
} else {
    // INSERT/UPDATE/DELETE，无数据行
    std::cout << "影响行数: " << rs.affectedRows() << '\n';
    std::cout << "最后插入ID: " << rs.lastInsertId() << '\n';
}
```

**安全的类型转换**:

```cpp
const auto& row = rs.row(0);

// 检查 NULL
if (row.isNull(0)) {
    std::cout << "值为 NULL\n";
} else {
    // 使用默认值
    std::string name = row.getString(0, "Unknown");
    int64_t age = row.getInt64(1, 0);
    double score = row.getDouble(2, 0.0);
}
```

### 5. 安全性

**防止 SQL 注入**:

```cpp
// 不安全：直接拼接用户输入
std::string username = getUserInput();
std::string sql = "SELECT * FROM users WHERE name = '" + username + "'";
client.query(sql);  // 危险！

// 安全：使用预处理语句
auto prep = client.prepare("SELECT * FROM users WHERE name = ?");
std::vector<std::optional<std::string>> params = {username};
client.stmtExecute(prep->statement_id, params);
```

**敏感信息处理**:

```cpp
// 不要在日志中输出密码
MysqlConfig config;
config.password = getPassword();

// 日志中隐藏密码
std::cout << "Connecting to " << config.host << ":" << config.port
          << " as " << config.username << " (password hidden)\n";
```

## 调试技巧

### 1. 启用详细日志

```cpp
// 在查询前后添加日志
std::cerr << "[DEBUG] Executing query: " << sql << '\n';
auto result = client.query(sql);
if (result) {
    std::cerr << "[DEBUG] Query succeeded, rows: " << result->rowCount() << '\n';
} else {
    std::cerr << "[DEBUG] Query failed: " << result.error().message() << '\n';
}
```

### 2. 检查连接状态

```cpp
// 同步客户端
if (!client.isConnected()) {
    std::cerr << "连接已断开\n";
    client.connect(config);
}

// 异步客户端
if (client.isClosed()) {
    std::cerr << "连接已关闭\n";
}
```

### 3. 测试查询

```cpp
// 使用简单查询测试连接
auto ping = client.ping();
if (ping) {
    std::cout << "连接正常\n";
} else {
    std::cout << "连接异常: " << ping.error().message() << '\n';
}

// 测试查询
auto test = client.query("SELECT 1");
if (test) {
    std::cout << "查询功能正常\n";
}
```

## 常见问题

### Q: 如何处理连接断开？

A: 检查错误类型并重连：

```cpp
auto result = client.query(sql);
if (!result && result.error().type() == MYSQL_ERROR_CONNECTION_CLOSED) {
    std::cerr << "连接断开，尝试重连\n";
    client.connect(config);
    result = client.query(sql);  // 重试
}
```

### Q: 连接池满了怎么办？

A: `acquire()` 会等待直到有连接可用。可以设置合理的 `max_connections`：

```cpp
pool_cfg.max_connections = 50;  // 根据实际负载调整
```

### Q: 如何处理大结果集？

A: 使用 `result_row_reserve_hint` 预留空间：

```cpp
AsyncMysqlConfig config;
config.result_row_reserve_hint = 10000;  // 预期 10000 行
AsyncMysqlClient client(scheduler, config);
```

### Q: 预处理语句何时关闭？

A: 使用完毕后立即关闭：

```cpp
auto prep = client.prepare(sql);
uint32_t stmt_id = prep->statement_id;

// 使用语句...

client.stmtClose(stmt_id);  // 释放服务端资源
```

## 下一步

- [示例代码](04-示例代码.md) - 更多实用示例
- [性能测试](05-性能测试.md) - 性能基准和优化
- [常见问题](07-常见问题.md) - 常见问题解答
